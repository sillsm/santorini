package Santorini

import (
	"reflect"
	"testing"
)

func TestPositionToString(t *testing.T) {
	testPosition1 := Position{
		0x1FAB212, 0x182A212, 0x102A012, 0x1020002,
		occupancy[11],
		occupancy[12],
		occupancy[16],
		occupancy[17],
		"",
		false,
	}

	got := testPosition1.String()
	want := "|0400300002001303040111124|11121617|"

	if got != want {
		t.Errorf("got %q, wanted %q", got, want)
	}
}

func TestNewPosition(t *testing.T) {
	position, e := NewPosition("|0400300002001303040111124|08050018|")
	if e != nil {
		t.Errorf("Error forming position")
	}
	got := position.String()
	want := "|0400300002001303040111124|05080018|"
	if got != want {
		t.Errorf("\ngot\t\t\t%q\n, wanted \t%q", got, want)
	}
}

func TestLegalMoves(t *testing.T) {
	position, e := NewPosition("|0400300002001303040111124|08050018|")
	if e != nil {
		t.Errorf("Error forming position")
	}
	tests := []struct {
		piece int
		want  []int
	}{
		{0, []int{6}},
		{1, []int{2, 6, 7}},
		{2, []int{3, 6, 7}},
		{3, []int{2, 7}},
		{4, []int{3, 9}}, // Do we want a piece on a won position to move anywhere?
		{5, []int{6, 10, 11}},
		{6, []int{2, 7, 10, 11, 12}},
		{7, []int{2, 3, 6, 11, 12}},
		{8, []int{2, 3, 7, 12, 14}},
		{9, []int{3, 4, 13, 14}},
		{10, []int{6, 11, 16}},
		{11, []int{6, 7, 10, 12, 16}},
		{12, []int{6, 7, 11, 16}},
		{13, []int{7, 9, 12, 14, 19}},
		{14, []int{19}},
		{15, []int{10, 11, 16, 20, 21}},
		{16, []int{10, 11, 12, 20, 21, 22}},
		{17, []int{11, 12, 13, 16, 21, 22, 23}},
		{18, []int{12, 14, 19, 22}},
		{19, []int{14, 23}},
		{20, []int{16, 21}},
		{21, []int{16, 20, 22}},
		{22, []int{16, 21, 23}},
		{23, []int{19, 22}},
		{24, []int{19, 23}},
	}

	for _, tc := range tests {
		got := legalMoves2(position, occupancy[tc.piece])
		var want []int32
		for _, elt := range tc.want {
			want = append(want, occupancy[elt])
		}
		if !reflect.DeepEqual(want, got) {
			t.Fatalf("on piece %v expected: %v, got: %v", tc.piece, want, got)
		}
	}
}

func TestLegalBuildMoves(t *testing.T) {
	position, e := NewPosition("|0400300002001303040111124|05080018|")
	if e != nil {
		t.Errorf("Error forming position")
	}
	// Initial position, white to move
	// |0400300002001303040111124|05080018|")
	want := []string{
		// A to 6 can build on 2, 5, 7, 10, 11, 12
		"|0410300002001303040111124|06080018|",
		"|0400310002001303040111124|06080018|",
		"|0400300102001303040111124|06080018|",
		"|0400300002101303040111124|06080018|",
		"|0400300002011303040111124|06080018|",
		"|0400300002002303040111124|06080018|", //???
		// A to 10 can build on 5, 6, 11, 15, 16
		"|0400310002001303040111124|08100018|",
		"|0400301002001303040111124|08100018|",
		"|0400300002011303040111124|08100018|",
		"|0400300002001304040111124|08100018|",
		"|0400300002001303140111124|08100018|",
		// A to 11 can build on 5, 6, 7, 10, 12, 15, 16
		"|0400310002001303040111124|08110018|", //5
		"|0400301002001303040111124|08110018|", //6
		"|0400300102001303040111124|08110018|", //7
		"|0400300002101303040111124|08110018|", //10
		"|0400300002002303040111124|08110018|", //12
		"|0400300002001304040111124|08110018|", //15
		"|0400300002001303140111124|08110018|", //16
		// B to 2 can build on 3, 6, 7, 8
		"|0401300002001303040111124|02050018|",
		"|0400301002001303040111124|02050018|",
		"|0400300102001303040111124|02050018|",
		"|0400300012001303040111124|02050018|",
		// B to 3 can build on 2, 4, 7, 8, 9
		"|0410300002001303040111124|03050018|",
		"|0400400002001303040111124|03050018|",
		"|0400300102001303040111124|03050018|",
		"|0400300012001303040111124|03050018|",
		"|0400300003001303040111124|03050018|",
		// B to 7 can build on 2, 3, 6, 8, 11, 12, 13
		"|0410300002001303040111124|05070018|", // 2
		"|0401300002001303040111124|05070018|", // 3
		"|0400301002001303040111124|05070018|", // 6
		"|0400300012001303040111124|05070018|", // 8
		"|0400300002011303040111124|05070018|", //???11
		"|0400300002002303040111124|05070018|",
		"|0400300002001403040111124|05070018|",
		// B to 12 can build on 6, 7, 8, 11, 13, 16
		"|0400301002001303040111124|05120018|",
		"|0400300102001303040111124|05120018|",
		"|0400300012001303040111124|05120018|",
		"|0400300002011303040111124|05120018|",
		"|0400300002001403040111124|05120018|",
		"|0400300002001303140111124|05120018|",
		// B to 14 can build on 8, 9, 13, 19
		"|0400300012001303040111124|05140018|",
		"|0400300003001303040111124|05140018|",
		"|0400300002001403040111124|05140018|",
		"|0400300002001303040211124|05140018|",
	}

	moves := legalBuildMoves(position)
	var got []string
	for _, mb := range moves {
		p := UpdatePosition(position, mb)
		got = append(got, p.String())
	}
	if !reflect.DeepEqual(want, got) {
		t.Fatalf("\nexpected: \n%v, \ngot: \n%v", want, got)
	}
}
